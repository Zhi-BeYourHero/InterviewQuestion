### 1. 缓存雪崩，缓存击穿和缓存穿透

**1、缓存雪崩**

缓存雪崩，缓存在同一时间内大面积失效，所有的请求都落在数据库中，数据库短时间内承受大量请求而崩掉

缓存同一时间内失效可能是服务器宕机或者设置了相同时间过期的key同时失效。

事前，尽量保证redis集群的高可用性，key的过期时间尽可能错开。
事中，本地ehcache缓存(先查本地缓存再查redis,然后数据库)+hystrix限流(每秒就接受一定量的请求)&降级(多余的请求走降级组件);
事后，利用持久化机制恢复缓存。

**针对 Redis 服务不可用的情况：**

1. 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
2. 限流，避免同时处理大量的请求。

**针对热点缓存失效的情况：**

1. 设置不同的失效时间比如随机设置缓存的失效时间。
2. 缓存永不失效。

**2、缓存击穿**

缓存击穿，在缓存失效的同时大量的请求同时访问，数据库短时间内承受大量请求而崩掉

1. 最简单粗暴的解决方案就是**让热点key不设置过期时间，即key一直存在于缓存中，更新时直接覆盖即可**。

2. 设置定时任务检测要过期的key，然后在将要过期的时候重新从数据库把数据刷新到缓存中，这样的方式增加系统复杂度，并且实现复杂。

3. 使用互斥锁的方案，**在缓存中没有数据去数据库查询时加上锁，让一个线程去查询数据库以及更新缓存，其他线程等待**，这样减小数据库压力。

**3、缓存穿透**

缓存穿透，查询一个根本不存在的数据，缓存层和数据库都不命中，失去了缓存的意义。
解决方案

​	1、拦截一些不合法的请求，比如例如id<0等等...

​	2、对空结果作缓存，意味着设置更多的键，占用更多的内存，所以要过期时间设置很短。

​    3、布隆过滤器：将所有可能存在数据哈希到一个bitMap中，拦截不存在的数据访问，缺点有一定的误识别率。

![image-20201114223023325](https://zhipic.oss-cn-beijing.aliyuncs.com/20210125130703.png)

